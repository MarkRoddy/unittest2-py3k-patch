Index: unittest2/test/test_suite.py
===================================================================
--- unittest2/test/test_suite.py	(revision 86724)
+++ unittest2/test/test_suite.py	(working copy)
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 import sys
 from .support import LoggingResult, TestEquality
Index: unittest2/test/test_assertions.py
===================================================================
--- unittest2/test/test_assertions.py	(revision 86724)
+++ unittest2/test/test_assertions.py	(working copy)
@@ -1,6 +1,6 @@
 import datetime
 
-import unittest
+import unittest2 as unittest
 
 
 class Test_Assertions(unittest.TestCase):
Index: unittest2/test/test_loader.py
===================================================================
--- unittest2/test/test_loader.py	(revision 86724)
+++ unittest2/test/test_loader.py	(working copy)
@@ -2,7 +2,7 @@
 import types
 
 
-import unittest
+import unittest2 as unittest
 
 
 class Test_TestLoader(unittest.TestCase):
@@ -524,7 +524,7 @@
         # We're going to try to load this module as a side-effect, so it
         # better not be loaded before we try.
         #
-        module_name = 'unittest.test.dummy'
+        module_name = 'unittest2.test.dummy'
         sys.modules.pop(module_name, None)
 
         loader = unittest.TestLoader()
@@ -907,7 +907,7 @@
         # We're going to try to load this module as a side-effect, so it
         # better not be loaded before we try.
         #
-        module_name = 'unittest.test.dummy'
+        module_name = 'unittest2.test.dummy'
         sys.modules.pop(module_name, None)
 
         loader = unittest.TestLoader()
Index: unittest2/test/test_discovery.py
===================================================================
--- unittest2/test/test_discovery.py	(revision 86724)
+++ unittest2/test/test_discovery.py	(working copy)
@@ -2,7 +2,7 @@
 import re
 import sys
 
-import unittest
+import unittest2 as unittest
 
 
 class TestableTestProgram(unittest.TestProgram):
@@ -373,7 +373,7 @@
             self.assertEqual(start_dir, expectedPath)
             return tests
         loader._find_tests = _find_tests
-        suite = loader.discover('unittest.test')
+        suite = loader.discover('unittest2.test')
         self.assertTrue(self.wasRun)
         self.assertEqual(suite._tests, tests)
 
Index: unittest2/test/test_program.py
===================================================================
--- unittest2/test/test_program.py	(revision 86724)
+++ unittest2/test/test_program.py	(working copy)
@@ -2,7 +2,7 @@
 
 import os
 import sys
-import unittest
+import unittest2 as unittest
 
 
 class Test_TestProgram(unittest.TestCase):
@@ -19,7 +19,7 @@
             self.assertEqual(start_dir, expectedPath)
             return tests
         loader._find_tests = _find_tests
-        suite = loader.discover('unittest.test')
+        suite = loader.discover('unittest2.test')
         self.assertTrue(self.wasRun)
         self.assertEqual(suite._tests, tests)
 
@@ -231,7 +231,7 @@
         self.assertIs(program.result, RESULT)
 
     def testCatchBreakInstallsHandler(self):
-        module = sys.modules['unittest.main']
+        module = sys.modules['unittest2.main']
         original = module.installHandler
         def restore():
             module.installHandler = original
Index: unittest2/test/test_runner.py
===================================================================
--- unittest2/test/test_runner.py	(revision 86724)
+++ unittest2/test/test_runner.py	(working copy)
@@ -1,7 +1,8 @@
 import io
 import pickle
+import sys
 
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult, ResultWithNoStartTestRunStopTestRun
 
@@ -221,6 +222,8 @@
         expected = ['startTestRun', 'stopTestRun']
         self.assertEqual(events, expected)
 
+    @unittest.skipIf(sys.version_info[:2] < (3, 2), 
+                      "io.StringIO() not pickleable until Python 3.2")
     def test_pickle_unpickle(self):
         # Issue #7197: a TextTestRunner should be (un)pickleable. This is
         # required by test_multiprocessing under Windows (in verbose mode).
Index: unittest2/test/test_case.py
===================================================================
--- unittest2/test/test_case.py	(revision 86724)
+++ unittest2/test/test_case.py	(working copy)
@@ -9,7 +9,7 @@
 from copy import deepcopy
 from test import support
 
-import unittest
+import unittest2 as unittest
 
 from .support import (
     TestEquality, TestHashing, LoggingResult,
Index: unittest2/test/support.py
===================================================================
--- unittest2/test/support.py	(revision 86724)
+++ unittest2/test/support.py	(working copy)
@@ -1,6 +1,11 @@
-import unittest
+import unittest2 as unittest
 
+import contextlib
+import re
+import sys
+import warnings
 
+
 class TestEquality(object):
     """Used as a mixin for TestCase"""
 
@@ -116,3 +121,86 @@
 
     def wasSuccessful(self):
         return True
+
+class WarningsRecorder(object):
+    """Convenience wrapper for the warnings list returned on
+       entry to the warnings.catch_warnings() context manager.
+    """
+    def __init__(self, warnings_list):
+        self._warnings = warnings_list
+        self._last = 0
+
+    def __getattr__(self, attr):
+        if len(self._warnings) > self._last:
+            return getattr(self._warnings[-1], attr)
+        elif attr in warnings.WarningMessage._WARNING_DETAILS:
+            return None
+        raise AttributeError("%r has no attribute %r" % (self, attr))
+
+    @property
+    def warnings(self):
+        return self._warnings[self._last:]
+
+    def reset(self):
+        self._last = len(self._warnings)
+
+def _filterwarnings(filters, quiet=False):
+    """Catch the warnings, then check if all the expected
+    warnings have been raised and re-raise unexpected warnings.
+    If 'quiet' is True, only re-raise the unexpected warnings.
+    """
+    # Clear the warning registry of the calling module
+    # in order to re-raise the warnings.
+    frame = sys._getframe(2)
+    registry = frame.f_globals.get('__warningregistry__')
+    if registry:
+        registry.clear()
+    with warnings.catch_warnings(record=True) as w:
+        # Set filter "always" to record all warnings.  Because
+        # test_warnings swap the module, we need to look up in
+        # the sys.modules dictionary.
+        sys.modules['warnings'].simplefilter("always")
+        yield WarningsRecorder(w)
+    # Filter the recorded warnings
+    reraise = [warning.message for warning in w]
+    missing = []
+    for msg, cat in filters:
+        seen = False
+        for exc in reraise[:]:
+            message = str(exc)
+            # Filter out the matching messages
+            if (re.match(msg, message, re.I) and
+                issubclass(exc.__class__, cat)):
+                seen = True
+                reraise.remove(exc)
+        if not seen and not quiet:
+            # This filter caught nothing
+            missing.append((msg, cat.__name__))
+    if reraise:
+        raise AssertionError("unhandled warning %r" % reraise[0])
+    if missing:
+        raise AssertionError("filter (%r, %s) did not catch any warning" %
+                             missing[0])
+
+@contextlib.contextmanager
+def check_warnings(*filters, **kwargs):
+    """Context manager to silence warnings.
+
+    Accept 2-tuples as positional arguments:
+        ("message regexp", WarningCategory)
+
+    Optional argument:
+     - if 'quiet' is True, it does not fail if a filter catches nothing
+        (default True without argument,
+         default False if some filters are defined)
+
+    Without argument, it defaults to:
+        check_warnings(("", Warning), quiet=True)
+    """
+    quiet = kwargs.get('quiet')
+    if not filters:
+        filters = (("", Warning),)
+        # Preserve backward compatibility
+        if quiet is None:
+            quiet = True
+    return _filterwarnings(filters, quiet)
Index: unittest2/test/test_result.py
===================================================================
--- unittest2/test/test_result.py	(revision 86724)
+++ unittest2/test/test_result.py	(working copy)
@@ -2,11 +2,10 @@
 import sys
 import textwrap
 
-from test import support
-
 import traceback
-import unittest
+import unittest2 as unittest
 
+from .support import check_warnings
 
 class Test_TestResult(unittest.TestCase):
     # Note: there are not separate tests for TestResult.wasSuccessful(),
@@ -313,7 +312,7 @@
 class Test_OldTestResult(unittest.TestCase):
 
     def assertOldResultWarning(self, test, failures):
-        with support.check_warnings(("TestResult has no add.+ method,",
+        with check_warnings(("TestResult has no add.+ method,",
                                      RuntimeWarning)):
             result = OldResult()
             test.run(result)
Index: unittest2/test/test_functiontestcase.py
===================================================================
--- unittest2/test/test_functiontestcase.py	(revision 86724)
+++ unittest2/test/test_functiontestcase.py	(working copy)
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult
 
Index: unittest2/test/test_setups.py
===================================================================
--- unittest2/test/test_setups.py	(revision 86724)
+++ unittest2/test/test_setups.py	(working copy)
@@ -1,7 +1,7 @@
 import io
 import sys
 
-import unittest
+import unittest2 as unittest
 
 
 def resultFactory(*_):
Index: unittest2/test/test_break.py
===================================================================
--- unittest2/test/test_break.py	(revision 86724)
+++ unittest2/test/test_break.py	(working copy)
@@ -5,7 +5,7 @@
 import signal
 import weakref
 
-import unittest
+import unittest2 as unittest
 
 
 @unittest.skipUnless(hasattr(os, 'kill'), "Test requires os.kill")
Index: unittest2/test/test_skipping.py
===================================================================
--- unittest2/test/test_skipping.py	(revision 86724)
+++ unittest2/test/test_skipping.py	(working copy)
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult
 
Index: unittest2/suite.py
===================================================================
--- unittest2/suite.py	(revision 86724)
+++ unittest2/suite.py	(working copy)
@@ -38,7 +38,7 @@
     def addTest(self, test):
         # sanity checks
         if not hasattr(test, '__call__'):
-            raise TypeError("{} is not callable".format(repr(test)))
+            raise TypeError("{0} is not callable".format(repr(test)))
         if isinstance(test, type) and issubclass(test,
                                                  (case.TestCase, TestSuite)):
             raise TypeError("TestCases and TestSuites must be instantiated "
Index: unittest2/compatibility.py
===================================================================
--- unittest2/compatibility.py	(revision 0)
+++ unittest2/compatibility.py	(revision 0)
@@ -0,0 +1,25 @@
+try:
+    from functools import cmp_to_key
+except ImportError:
+    # Python 3.0 / 3.1
+    def cmp_to_key(mycmp):
+        """Convert a cmp= function into a key= function"""
+        class K(object):
+            def __init__(self, obj, *args):
+                self.obj = obj
+            def __lt__(self, other):
+                return mycmp(self.obj, other.obj) < 0
+            def __gt__(self, other):
+                return mycmp(self.obj, other.obj) > 0
+            def __eq__(self, other):
+                return mycmp(self.obj, other.obj) == 0
+            def __le__(self, other):
+                return mycmp(self.obj, other.obj) <= 0
+            def __ge__(self, other):
+                return mycmp(self.obj, other.obj) >= 0
+            def __ne__(self, other):
+                return mycmp(self.obj, other.obj) != 0
+            def __hash__(self):
+                raise TypeError('hash not implemented')
+        return K
+
Index: unittest2/case.py
===================================================================
--- unittest2/case.py	(revision 86724)
+++ unittest2/case.py	(working copy)
@@ -6,6 +6,7 @@
 import pprint
 import re
 import warnings
+import unittest
 
 from . import result
 from .util import (strclass, safe_repr, sorted_list_difference,
@@ -212,7 +213,7 @@
         return default
 
 
-class TestCase(object):
+class TestCase(unittest.TestCase):
     """A class whose instances are single test cases.
 
     By default, the test code itself should be placed in a method named
Index: unittest2/__init__.py
===================================================================
--- unittest2/__init__.py	(revision 86724)
+++ unittest2/__init__.py	(working copy)
@@ -9,9 +9,9 @@
 
 Simple usage:
 
-    import unittest
+    import unittest2
 
-    class IntegerArithmenticTestCase(unittest.TestCase):
+    class IntegerArithmenticTestCase(unittest2.TestCase):
         def testAdd(self):  ## test method names begin 'test*'
             self.assertEqual((1 + 2), 3)
             self.assertEqual(0 + 1, 1)
@@ -20,7 +20,7 @@
             self.assertEqual((5 * 8), 40)
 
     if __name__ == '__main__':
-        unittest.main()
+        unittest2.main()
 
 Further information is available in the bundled documentation, and from
 
Index: unittest2/loader.py
===================================================================
--- unittest2/loader.py	(revision 86724)
+++ unittest2/loader.py	(working copy)
@@ -5,11 +5,12 @@
 import sys
 import traceback
 import types
-import functools
+import unittest
 
 from fnmatch import fnmatch
 
 from . import case, suite, util
+from .compatibility import cmp_to_key
 
 __unittest = True
 
@@ -142,7 +143,7 @@
         testFnNames = testFnNames = list(filter(isTestMethod,
                                                 dir(testCaseClass)))
         if self.sortTestMethodsUsing:
-            testFnNames.sort(key=functools.cmp_to_key(self.sortTestMethodsUsing))
+            testFnNames.sort(key=cmp_to_key(self.sortTestMethodsUsing))
         return testFnNames
 
     def discover(self, start_dir, pattern='test*.py', top_level_dir=None):
